<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Blob Classifier MLP</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0e1117;
      --panel: #161b22;
      --accent: #238636;
      --border: #30363d;
      --text: #c9d1d9;
      --danger: #da3633;
      --warn: #d29922;
    }
    body {
      margin:0; font-family:system-ui,-apple-system,Roboto,Segoe UI,sans-serif; background:var(--bg); color:var(--text);
      display:flex; flex-direction:column; min-height:100vh; }
    header { padding:0.75rem 1rem; background:var(--panel); border-bottom:1px solid var(--border); }
    h1 { margin:0; font-size:1.1rem; font-weight:600; }
    main { flex:1; display:grid; grid-template-columns:minmax(360px,360px) 1fr; gap:1.5rem; padding:1rem; align-items:start; }
    @media (max-width:900px){ main { grid-template-columns:1fr; } }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:6px; padding:0.75rem 0.9rem; display:flex; flex-direction:column; gap:0.65rem; }
    .panel h2 { margin:0 0 0.25rem; font-size:0.95rem; font-weight:600; }
    label { display:flex; flex-direction:column; font-size:0.7rem; text-transform:uppercase; letter-spacing:0.05em; gap:0.25rem; }
    input[type=text], input[type=number], select { background:#0d1117; border:1px solid var(--border); color:var(--text); padding:0.4rem 0.5rem; border-radius:4px; font-size:0.8rem; }
    input[type=number]::-webkit-inner-spin-button { opacity:0.4; }
    .row { display:flex; gap:0.5rem; }
    .wrap { display:flex; flex-wrap:wrap; gap:0.6rem; }
    button { cursor:pointer; background:var(--accent); color:#fff; border:1px solid var(--border); padding:0.5rem 0.75rem; font-size:0.8rem; border-radius:4px; font-weight:600; letter-spacing:0.5px; transition:background 0.2s; }
    button:hover { background:#2ea043; }
    button.secondary { background:#30363d; }
    button.secondary:hover { background:#3d444d; }
    button.danger { background:var(--danger); }
    button.danger:hover { background:#ef4442; }
    .status-bar { display:flex; gap:0.75rem; flex-wrap:wrap; font-size:0.75rem; align-items:center; }
    .badge { padding:0.2rem 0.5rem; border-radius:12px; font-weight:600; letter-spacing:0.5px; font-size:0.65rem; }
    .running { background:var(--accent); }
    .stopped { background:var(--danger); }
    .done { background:var(--warn); color:#000; }
    #controls { width:360px; box-sizing:border-box; }
    canvas { width:100%; height:auto; background:#000; border:1px solid var(--border); border-radius:6px; display:block; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:0.55rem; }
    .triple-grid { display:grid; grid-template-columns:1fr 1fr 1fr; gap:0.55rem; }
    .footer-note { font-size:0.6rem; opacity:0.6; }
    .checkbox-row { display:flex; align-items:center; gap:0.4rem; font-size:0.7rem; }
    input[type=checkbox] { width:16px; height:16px; }
    a { color:var(--accent); }
  </style>
</head>
<body>
  <header>
    <h1>Blob Classifier â€“ MLP Decision Boundary Visualizer</h1>
  </header>
  <main>
    <section class="panel" id="controls">
      <h2>Parameters</h2>
      <label>Hidden Layers (Comma Sizes)
        <input id="layers" type="text" value="32,32" placeholder="e.g. 64,32" />
      </label>
      <div class="grid">
        <label>Learning Rate
          <input id="lr" type="number" step="0.001" value="0.05" min="0.0001" />
        </label>
        <label>Epochs
          <input id="epochs" type="number" value="200" min="1" />
        </label>
        <label>Points / Class
          <input id="points" type="number" value="150" min="5" />
        </label>
        <label>Variance
          <input id="variance" type="number" value="0.1" step="0.01" min="0" />
        </label>
      </div>
      <div class="triple-grid">
        <label>Ep / Frame
          <input id="epf" type="number" value="1" min="1" />
        </label>
        <label>Grid Res
          <input id="gridRes" type="number" value="140" min="40" max="300" />
        </label>
        <label>Pt Size
          <input id="ptSize" type="number" value="5" min="1" max="12" />
        </label>
      </div>
      <label>Dataset
        <select id="dataset">
          <option value="moons">Moons (2 classes)</option>
          <option value="diagonal">Diagonal (3 classes)</option>
          <option value="quadrant">Quadrant (4 classes)</option>
        </select>
      </label>
      <label>Moon Gap
        <input id="moonGap" type="number" value="0.3" step="0.05" />
      </label>
      <div class="checkbox-row">
        <input id="showBoundaries" type="checkbox" checked />
        <span>Boundary Lines</span>
      </div>
      <h2>Actions</h2>
      <div class="wrap">
        <button id="btnGen">Generate Data</button>
        <button id="btnStart">Start Training</button>
        <button id="btnStop" class="secondary">Stop</button>
        <button id="btnReset" class="danger">Reset NN</button>
        <button id="btnFast" class="secondary" title="Run all remaining epochs instantly">Fast Finish</button>
      </div>
      <h2>Status</h2>
      <div class="status-bar">
        <span id="runState" class="badge stopped">STOPPED</span>
        <span>Epoch: <strong id="epochCount">0</strong></span>
        <span>Loss: <strong id="lossVal">-</strong></span>
      </div>
      <p class="footer-note">Training uses full-batch gradient descent with ReLU hidden layers and softmax output (cross-entropy loss). Decision regions update each epoch.</p>
    </section>
    <section class="panel" style="display:flex; flex-direction:column; flex:1; min-height:400px;">
      <h2 style="margin:0 0 0.5rem;">Decision Boundary</h2>
      <canvas id="canvas" width="640" height="640"></canvas>
    </section>
  </main>
  <script>
    // Utility random gaussian via Box-Muller
    function randn() {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const ui = {
      layers: document.getElementById('layers'),
      lr: document.getElementById('lr'),
      epochs: document.getElementById('epochs'),
      points: document.getElementById('points'),
      variance: document.getElementById('variance'),
      dataset: document.getElementById('dataset'),
      moonGap: document.getElementById('moonGap'),
      showBoundaries: document.getElementById('showBoundaries'),
      btnGen: document.getElementById('btnGen'),
      btnStart: document.getElementById('btnStart'),
      btnStop: document.getElementById('btnStop'),
      btnReset: document.getElementById('btnReset'),
      btnFast: document.getElementById('btnFast'),
      runState: document.getElementById('runState'),
      epochCount: document.getElementById('epochCount'),
      lossVal: document.getElementById('lossVal'),
      epf: document.getElementById('epf'),
      gridRes: document.getElementById('gridRes'),
      ptSize: document.getElementById('ptSize')
    };

    let data = [];
    let nClasses = 0;
    let epochTarget = 0;
    let currentEpoch = 0;
    let running = false;
    let network = null;

    const colors = ['#ff4d4d','#4d9dff','#4dff88','#ffb84d','#b84dff','#4dffd5'];

    function generateData() {
      const pts = parseInt(ui.points.value,10);
      const variance = parseFloat(ui.variance.value);
      const moonGap = parseFloat(ui.moonGap.value);
      const ds = ui.dataset.value;
      data = [];
      if (ds === 'moons') {
        nClasses = 2;
        const n = pts;
        for (let i=0;i<n;i++) {
          const a = Math.random()*Math.PI;
          let x = 0.5 * Math.cos(a);
          let y = 0.5 * Math.sin(a);
          x += randn()*variance; y += randn()*variance;
          data.push({x,y,label:0});
        }
        for (let i=0;i<n;i++) {
          const a = Math.random()*Math.PI;
          let x = 0.5 * (1 - Math.cos(a)) - 0.25;
          let y = -0.5 * Math.sin(a) - moonGap * 0.5;
          x += randn()*variance; y += randn()*variance;
          data.push({x,y,label:1});
        }
      } else if (ds === 'diagonal') {
        // Four quadrant clusters, two diagonal share label -> 3 classes total
        // Chosen mapping: top-left (0), top-right (1), bottom-left (2), bottom-right (0)
        nClasses = 3;
        const centers = [
          {cx:-0.6, cy:0.6, label:0},  // top-left (y positive)
          {cx:0.6, cy:0.6, label:1},   // top-right
          {cx:-0.6, cy:-0.6, label:2}, // bottom-left
          {cx:0.6, cy:-0.6, label:0}   // bottom-right (same as top-left)
        ];
        centers.forEach(cInfo => {
          for (let i=0;i<pts;i++) {
            const x = cInfo.cx + randn()*variance;
            const y = cInfo.cy + randn()*variance;
            data.push({x,y,label:cInfo.label});
          }
        });
      } else if (ds === 'quadrant') {
        nClasses = 4;
        const centers = [[-0.6,-0.6],[-0.6,0.6],[0.6,-0.6],[0.6,0.6]];
        for (let c=0;c<centers.length;c++) {
          for (let i=0;i<pts;i++) {
            let [cx,cy]=centers[c];
            const x = cx + randn()*variance;
            const y = cy + randn()*variance;
            data.push({x,y,label:c});
          }
        }
      }
      normalizeData();
      resetNetwork();
      currentEpoch = 0;
      ui.epochCount.textContent = '0';
      ui.lossVal.textContent = '-';
      draw();
    }

    function normalizeData() {
      if (!data.length) return;
      let minX = Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
      data.forEach(p=>{ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
      const pad = 0.2;
      minX -= pad; maxX += pad; minY -= pad; maxY += pad;
      data.forEach(p=>{
        p.nx = (p.x - minX)/(maxX-minX)*2 -1;
        p.ny = (p.y - minY)/(maxY-minY)*2 -1;
      });
      // store bounds for rendering grid
      data.bounds = {minX,maxX,minY,maxY};
    }

    class MLP {
      constructor(layerSizes) {
        this.sizes = layerSizes;
        this.weights = [];
        this.biases = [];
        for (let i=0;i<layerSizes.length-1;i++) {
          const inSize = layerSizes[i];
          const outSize = layerSizes[i+1];
          const w = new Array(outSize).fill(0).map(()=> new Array(inSize).fill(0).map(()=> (Math.random()*2-1) * Math.sqrt(2/inSize)));
          const b = new Array(outSize).fill(0);
          this.weights.push(w); this.biases.push(b);
        }
      }
      forward(x) {
        let a = x.slice();
        const activations = [a];
        const zs = [];
        for (let i=0;i<this.weights.length;i++) {
          const w = this.weights[i];
          const b = this.biases[i];
          const z = new Array(w.length).fill(0);
          for (let o=0;o<w.length;o++) {
            let sum = b[o];
            for (let j=0;j<w[o].length;j++) sum += w[o][j]*a[j];
            z[o]=sum;
          }
          let next;
          if (i < this.weights.length-1) {
            // ReLU
            next = z.map(v=> v>0?v:0);
          } else {
            // output logits
            next = z.slice();
          }
          zs.push(z); activations.push(next); a = next;
        }
        return {activations,zs};
      }
      predict(x) {
        const {activations} = this.forward(x);
        const logits = activations[activations.length-1];
        const maxLogit = Math.max(...logits);
        const exps = logits.map(v=> Math.exp(v - maxLogit));
        const sum = exps.reduce((a,b)=>a+b,0);
        const probs = exps.map(e=> e/sum);
        return probs;
      }
      trainBatch(batch, lr) {
        // Full batch gradient descent
        const N = batch.length;
        // Forward for each sample store activations
        const activationsList = [];
        const logitsList = [];
        batch.forEach(p=>{
          const {activations} = this.forward([p.nx,p.ny]);
          activationsList.push(activations);
          logitsList.push(activations[activations.length-1]);
        });
        // Compute softmax & loss gradient at output
        const dWeights = this.weights.map(w=> w.map(row=> row.map(()=>0)));
        const dBiases = this.biases.map(b=> b.map(()=>0));
        let lossSum = 0;
        for (let idx=0; idx<batch.length; idx++) {
          const logits = logitsList[idx];
            const maxLogit = Math.max(...logits);
            const exps = logits.map(v=> Math.exp(v-maxLogit));
            const s = exps.reduce((a,b)=>a+b,0);
            const probs = exps.map(e=> e/s);
            const label = batch[idx].label;
            lossSum += -Math.log(probs[label] + 1e-9);
            // gradient of loss w.r.t logits
            const dLogits = probs.map((p,i)=> p - (i===label?1:0));
            // Backprop
            let delta = dLogits; // size = output layer
            for (let layer = this.weights.length-1; layer>=0; layer--) {
              const aPrev = activationsList[idx][layer]; // activations before layer
              // accumulate weight gradients
              for (let o=0;o<this.weights[layer].length;o++) {
                for (let j=0;j<this.weights[layer][o].length;j++) {
                  dWeights[layer][o][j] += delta[o] * aPrev[j] / N;
                }
                dBiases[layer][o] += delta[o] / N;
              }
              if (layer>0) {
                // compute delta for previous layer
                const wT = this.weights[layer];
                const newDelta = new Array(this.sizes[layer]).fill(0);
                for (let j=0;j<newDelta.length;j++) {
                  let sum=0; for (let o=0;o<wT.length;o++) sum += wT[o][j]*delta[o];
                  // ReLU derivative on activationsList[idx][layer][j] which is post-ReLU
                  const activated = activationsList[idx][layer][j];
                  newDelta[j] = activated>0 ? sum : 0;
                }
                delta = newDelta;
              }
            }
        }
        const loss = lossSum / batch.length;
        // Update weights
        for (let l=0;l<this.weights.length;l++) {
          for (let o=0;o<this.weights[l].length;o++) {
            for (let j=0;j<this.weights[l][o].length;j++) {
              this.weights[l][o][j] -= lr * dWeights[l][o][j];
            }
            this.biases[l][o] -= lr * dBiases[l][o];
          }
        }
        return loss;
      }
    }

    function parseLayers() {
      const txt = ui.layers.value.trim();
      if (!txt) return [32,32];
      return txt.split(',').map(s=> parseInt(s.trim(),10)).filter(n=> !isNaN(n) && n>0);
    }

    function resetNetwork() {
      const hidden = parseLayers();
      const sizes = [2, ...hidden, nClasses];
      network = new MLP(sizes);
      currentEpoch = 0;
      ui.epochCount.textContent = '0';
      ui.lossVal.textContent = '-';
      setStatus('STOPPED');
      draw();
    }

    function setStatus(state) {
      ui.runState.textContent = state.toUpperCase();
      ui.runState.className = 'badge ' + (state==='running'?'running': state==='done'?'done':'stopped');
    }

    function startTraining() {
      if (!data.length) generateData();
      epochTarget = parseInt(ui.epochs.value,10);
      running = true;
      setStatus('running');
      requestAnimationFrame(trainStep);
    }

    function stopTraining() {
      running = false;
      if (currentEpoch >= epochTarget) setStatus('done'); else setStatus('stopped');
    }

    function trainStep() {
      if (!running) return;
      if (currentEpoch >= epochTarget) { running=false; setStatus('done'); return; }
      const lr = parseFloat(ui.lr.value);
      const epf = Math.max(1, parseInt(ui.epf.value,10) || 1);
      let loss = 0;
      for (let i=0; i<epf && currentEpoch < epochTarget; i++) {
        loss = network.trainBatch(data, lr);
        currentEpoch++;
      }
      ui.epochCount.textContent = currentEpoch;
      ui.lossVal.textContent = loss.toFixed(4);
      draw(loss);
      requestAnimationFrame(trainStep);
    }

    function draw(loss) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawDecisionRegions();
      drawPoints();
      if (ui.showBoundaries.checked) drawBoundaries();
    }

    function dataToCanvas(x,y) {
      // Data normalized to [-1,1]; map to canvas
      const cx = (x+1)/2 * canvas.width;
      const cy = canvas.height - (y+1)/2 * canvas.height;
      return [cx,cy];
    }

    function drawPoints() {
      const size = parseInt(ui.ptSize.value,10) || 5;
      data.forEach(p=> {
        const [cx,cy] = dataToCanvas(p.nx,p.ny);
        ctx.fillStyle = colors[p.label % colors.length];
        ctx.beginPath();
        ctx.arc(cx,cy,size,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      });
    }

    function drawDecisionRegions() {
      if (!network) return;
      const userGrid = parseInt(ui.gridRes.value,10) || 140;
      const grid = Math.max(40, Math.min(300, userGrid));
      const cellW = canvas.width / grid;
      const cellH = canvas.height / grid;
      const alpha = 0.25;
      for (let i=0;i<grid;i++) {
        for (let j=0;j<grid;j++) {
          const x = (i/(grid-1))*2 -1;
          const y = (j/(grid-1))*2 -1;
          const probs = network.predict([x,y]);
          const cls = probs.indexOf(Math.max(...probs));
          ctx.fillStyle = hexWithAlpha(colors[cls % colors.length], alpha);
          ctx.fillRect(i*cellW, canvas.height - (j+1)*cellH, cellW, cellH);
        }
      }
    }

    function hexWithAlpha(hex, alpha) {
      // Convert #rrggbb to rgba
      const bigint = parseInt(hex.slice(1),16);
      const r = (bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function drawBoundaries() {
      if (!network) return;
      const userGrid = parseInt(ui.gridRes.value,10) || 140;
      const grid = Math.max(40, Math.min(300, userGrid));
      const classifications = [];
      for (let i=0;i<grid;i++) {
        classifications[i] = [];
        for (let j=0;j<grid;j++) {
          const x = (i/(grid-1))*2 -1;
          const y = (j/(grid-1))*2 -1;
          const probs = network.predict([x,y]);
          classifications[i][j] = probs.indexOf(Math.max(...probs));
        }
      }
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 1;
      const cellW = canvas.width / grid;
      const cellH = canvas.height / grid;
      for (let i=0;i<grid-1;i++) {
        for (let j=0;j<grid-1;j++) {
          const c = classifications[i][j];
          const right = classifications[i+1][j];
          const up = classifications[i][j+1];
          if (c !== right) {
            const x = (i+1)*cellW;
            const y0 = canvas.height - j*cellH;
            const y1 = canvas.height - (j+1)*cellH;
            ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
          }
          if (c !== up) {
            const y = canvas.height - (j+1)*cellH;
            const x0 = i*cellW; const x1 = (i+1)*cellW;
            ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
          }
        }
      }
      ctx.restore();
    }

    // Event handlers
    ui.btnGen.addEventListener('click', ()=>{ generateData(); });
    ui.btnStart.addEventListener('click', ()=>{ if (!running) startTraining(); });
    ui.btnStop.addEventListener('click', ()=>{ stopTraining(); });
    ui.btnReset.addEventListener('click', ()=>{ resetNetwork(); });
    ui.dataset.addEventListener('change', ()=>{ generateData(); });
    ui.layers.addEventListener('change', ()=>{ resetNetwork(); });
    ui.gridRes.addEventListener('change', ()=>{ draw(); });
    ui.ptSize.addEventListener('change', ()=>{ draw(); });
    ui.epf.addEventListener('change', ()=>{ /* no immediate action */ });
    ui.btnFast.addEventListener('click', ()=>{
      if (!data.length) generateData();
      const lr = parseFloat(ui.lr.value);
      epochTarget = parseInt(ui.epochs.value,10);
      setStatus('running');
      let loss = 0;
      while (currentEpoch < epochTarget) {
        loss = network.trainBatch(data, lr);
        currentEpoch++;
        if (currentEpoch % 10 === 0) {
          ui.epochCount.textContent = currentEpoch;
          ui.lossVal.textContent = loss.toFixed(4);
        }
      }
      ui.epochCount.textContent = currentEpoch;
      ui.lossVal.textContent = loss.toFixed(4);
      draw(loss);
      setStatus('done');
    });

    // Initial
    generateData();
  </script>
</body>
</html>